\subsection{Abstraction gap}
During the problem analysis we considered Java as our technological hypothesis.
We realized that Java’s unique communication tool is procedure calls, with
OO paradigm it becomes really difficult to implement modular communication
where entities are completely independent and loosely coupled. We need a new
way to let our components interact. In agreement with our vision, we understand
that the best way to overcome this problem is to develop a new software
infrastructure that will map more strictly to our model representation than Java
paradigms. This infrastructure will be used not only in this project, but every
future developed process that will have the same needs because, according to
our visions, we want to develop reusable code.
Our platform must offer some functionalities. First of all we need a formal definition
of a System:
a System is one or more active entities that interact to reach some goal or provide
some functionalities. A system is composed by one or more Contexts, a Contexts
identifies a logical location at deployment time. The System enables the communication
between the entities and synchronizes them so Entities must interact
using the System only. In this way a System can be concentrated or distributed
seamlessly for the application designer. Defined this general perspective we can
introduce two paradigms:
\begin{itemize}
	\item Message Based Programming
	\item Event Based Programming
\end{itemize}
\textbf{Message Based Programming:} to introduce message based programming we
need to define the entities that can exchange messages. We will call these entities
QActors.
QActors in our platform are not message-driven but message-based. The core
difference between message driven and message based is that message driven
systems can be only reactive to messages instead of being able to decide when
messages and which messages are functional to evaluate. In this way we can
model not only reactive entities but also proactive ones. QActors live in a context
and they can communicate with other QActors using different communication
primitives, like \textit{dispatch}: an asynchronous message without returning information. \\
QActors can receive messages using the receive message primitives, like \textit{receiveMessage} which extracts the first message from the actor message queue. \\\\
\textbf{Event Based Programming}: we needed to define the concept of events as pervasive messages that are spread in the system. The message passing paradigm
lacks of this feature because all messages are point to point. Events are a form
of asynchronous communication that is not point to point. In our system our
entities can declare to be interested in an event, when that event will be emitted
the entities can react in some way.
When we introduced proactive QActors we realized that we needed the concept
of Plan. A Plan is a sequence of actions (you can see actions as programming
language instructions), every plan has its own logic and can switch to a different
plan. When the execution of a plan reaches its end it can specify if the
previous plan must continue its execution or suspend it. This abstraction was
lacking of the better part of message/event driven programming: reactivity. This
gap is filled by Asynchronous Actions, which are tipically time
consuming actions that can be executed in blocking or non-blocking way. When
runing an asynchronous action its execution can be interrupted by specified
events and the QActor must react executing the associated plan. The logic of
plan switching is defined as above. QActors are able to execute actions in two
ways:
\begin{itemize}
	\item executing compiled code
	\item interpreting meta code on the fly
\end{itemize} 
Adding the possibility to interpret code on the fly permits to the QActor to enrich
its behaviour during runtime. The just described platform will be realized with
Java Programming Language (our technologic assumption) but will be made
to be interoperable with other technologies by the extensive use of text-based
messages using the standard socket technology.
On top of the API offered by the platform we’ll realize a DSL using the xtext
framework. With the use of such tool we’ll generate a declarative language that
will provide two main benefits:
\begin{itemize}
	\item a formal and human readable language to describe the problem analysis,
	entities interactions and system topology;
	\item code generation to be able to customize and execute the artifacts generated by the DSL interpretation.
\end{itemize}
With such tools in mind we can reimagine the traditional problem analysis
techniques and tackle the problems in a formal and more convenient way.